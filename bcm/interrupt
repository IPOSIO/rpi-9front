arch.c:	ureg->pc = p->sched.pc;
arch.c:	ureg->sp = p->sched.sp+4;
arch.c:	ureg->r14 = PTR2UINT(sched);
arch.c:	 * Plan 9 is a 32-bit O/S, and the hardware it runs on
arch.c:	 * does not usually have instructions which move 64-bit
arch.c:	 * with 32-bit move instructions. Therefore, the compiler
arch.c:	 * (and hardware) usually only enforce 32-bit alignment,
arch.c:	if((align != 0 && !(align & (align-1))) && !(addr & (align-1)))
arch.c:	tos = (Tos*)(USTKTOP-sizeof(Tos));
arch.c:	tos->kcycles += t - up->kentry;
arch.c:	tos->pcycles = up->pcycles;
arch.c:	tos->cyclefreq = m->cpuhz;
arch.c:	tos->pid = up->pid;
arch.c:	Ureg *ureg = up->dbgreg;
arch.c:	return ureg->pc;
arch.c:	up->kpfun(up->kparg);
arch.c:	p->sched.pc = PTR2UINT(linkproc);
arch.c:	p->sched.sp = PTR2UINT(p->kstack+KSTACK);
arch.c:	p->kpfun = func;
arch.c:	p->kparg = arg;
arch.c:	ureg = p->dbgreg;
arch.c:	return ureg->pc;
arch.c:	p->kentry = up->kentry;
arch.c:	p->pcycles = -p->kentry;
arch.c:	p->pcycles += t;
arch.c:	if(p->kp)
arch.c:	p->pcycles -= t;
arch.c:	return (ureg->psr & PsrMask) == PsrMusr;
archbcm.c: * bcm2835 (e.g. original raspberry pi) architecture-specific stuff
archbcm.c:	seprint(buf, buf + size, "1176JZF-S");
archbcm.c:	print("cpu%d: %dMHz ARM %s\n", m->machno, m->cpumhz, name);
archbcm.c:	ether->type = "usb";
archbcm.c:	ether->ctlrno = ctlrno;
archbcm.c:	ether->irq = -1;
archbcm.c:	ether->nopt = 0;
archbcm.c:	v = --*p;
archbcm.c:	v = --*p;
archbcm2.c: * bcm2836 (e.g.raspberry pi 2) architecture-specific stuff
archbcm2.c:		p = seprint(buf, buf + size, "Cortex-A7");
archbcm2.c:		p = seprint(buf, buf + size, "Cortex-A53");
archbcm2.c:		p = seprint(buf, buf + size, "Unknown-%#x", part);
archbcm2.c:	print("cpu%d: %dMHz ARM %s\n", m->machno, m->cpumhz, name);
archbcm2.c:	if(mb->clr[cpu].startcpu)
archbcm2.c:		return -1;
archbcm2.c:	mb->set[cpu].startcpu = PADDR(cpureset);
archbcm2.c:		if(mb->clr[cpu].startcpu == 0)
archbcm2.c:	mb->clr[cpu].startcpu = PADDR(cpureset);
archbcm2.c:	mb->set[cpu].doorbell = 1;
archbcm2.c:	mb->clr[cpu].mbox1 = 1;
archbcm2.c:	mb->set[cpu].mbox1 = 1;
archbcm2.c:	ether->type = "usb";
archbcm2.c:	ether->ctlrno = ctlrno;
archbcm2.c:	ether->irq = -1;
archbcm2.c:	ether->nopt = 0;
archbcm2.c:	mb->clr[cpu].doorbell = 1;
archbcm2.c:	machon(m->machno);
clock.c: *    All are free-running up-counters
clock.c: *  Cortex-a7 has local generic timers per cpu (which we run at 1MHz)
clock.c: *   For smp on bcm2836, use local generic timer for interrupts on cpu1-3
clock.c:	/* generic timer (cortex-a7) */
clock.c:	if(m->machno != 0)
clock.c:		panic("cpu%d: unexpected system timer interrupt", m->machno);
clock.c:	tn->cs = 1<<3;
clock.c:	if(m->machno == 0)
clock.c:	tm->ctl = 0;
clock.c:		if(m->machno == 0){
clock.c:	tstart = tn->clo;
clock.c:	}while(tn->clo == tstart);
clock.c:	}while(tn->clo != tend);
clock.c:	t1 -= t0;
clock.c:	m->cpuhz = 100 * t1;
clock.c:	m->cpumhz = (m->cpuhz + Mhz/2 - 1) / Mhz;
clock.c:	m->cyclefreq = m->cpuhz;
clock.c:	if(m->machno == 0){
clock.c:		tn->c3 = tn->clo - 1;
clock.c:		tm->load = 0;
clock.c:		tm->ctl = TmrPrescale1|CntEnable|CntWidth32;
clock.c:	period = next - now;
clock.c:	if(m->machno > 0){
clock.c:		tn->c3 = tn->clo + period;
clock.c:		hi = tn->chi;
clock.c:		lo = tn->clo;
clock.c:	}while(tn->chi != hi);
clock.c:	return tm->count;
clock.c:		tm->ctl |= TmrEnable|TmrIntEnable;
clock.c:		tm->load = n;
clock.c:		tm->load = 0;
clock.c:		tm->ctl &= ~(TmrEnable|TmrIntEnable);
clock.c:		tm->irq = 1;
clock.c:	return ((Systimers*)SYSTIMERS)->clo;
clock.c:	now = tn->clo;
clock.c:	while(tn->clo - now < diff)
clock.c:	while(--n >= 0)
devarch.c:	switch((ulong)c->qid.path){
devarch.c:		if(c->qid.path < narchdir && (fn = readfn[c->qid.path]))
devarch.c:	if(c->qid.path < narchdir && (fn = writefn[c->qid.path]))
devarch.c:	snprint(str, sizeof str, "ARM %s %d\n", name, m->cpumhz);
devfakertc.c:	if(c->qid.type & QTDIR)
devfakertc.c:	switch((ulong)c->qid.path){
devfakertc.c:	switch((ulong)c->qid.path){
devgpio.c:	Alt1, Alt2, Alt3, -1};
devgpio.c:	if(c->qid.path == Qdir)
devgpio.c:	if(c->qid.type & QTDIR)
devgpio.c:	pin = atoi(cb->f[1]);
devgpio.c:	switch(ct->index) {
devgpio.c:			if(strcmp(funcs[i], cb->f[2]) == 0)
devgpio.c:		if(ifuncs[i] == -1) {
devgpio.c:		gpioout(pin, atoi(cb->f[2]));
devi2c.c:	d->ref = 1;
devi2c.c:	d->addr = addr;
devi2c.c:	d->salen = 0;
devi2c.c:	d->tenbit = addr >= 128;
devi2c.c:	memmove(d->tab, i2ctab, sizeof(d->tab));
devi2c.c:	sprint(d->tab[1].name, "i2c.%lux.data", addr);
devi2c.c:	sprint(d->tab[2].name, "i2c.%lux.ctl", addr);
devi2c.c:	c->aux = d;
devi2c.c:	d = c->aux;
devi2c.c:	wq = devwalk(c, nc, name, nname, d->tab, nelem(d->tab), devgen);
devi2c.c:	if(wq != nil && wq->clone != nil && wq->clone != c)
devi2c.c:	d = c->aux;
devi2c.c:	return devstat(c, dp, n, d->tab, nelem(d->tab), devgen);
devi2c.c:	d = c->aux;
devi2c.c:	return devopen(c, omode, d->tab, nelem(d->tab), devgen);
devi2c.c:	d = c->aux;
devi2c.c:	d = c->aux;
devi2c.c:	switch((ulong)c->qid.path){
devi2c.c:		return devdirread(c, a, n, d->tab, nelem(d->tab), devgen);
devi2c.c:		len = d->tab[1].length;
devi2c.c:			n = len - offset;
devi2c.c:		e = seprint(s, s+READSTR, "size %lud\n", (ulong)d->tab[1].length);
devi2c.c:		if(d->salen)
devi2c.c:			e = seprint(e, s+READSTR, "subaddress %d\n", d->salen);
devi2c.c:		if(d->tenbit)
devi2c.c:	switch((ulong)c->qid.path){
devi2c.c:		d = c->aux;
devi2c.c:		len = d->tab[1].length;
devi2c.c:			n = len - offset;
devi2c.c:		if(cb->nf < 1)
devi2c.c:		d = c->aux;
devi2c.c:		if(strcmp(cb->f[0], "subaddress") == 0){
devi2c.c:			if(cb->nf > 1){
devi2c.c:				len = strtol(cb->f[1], nil, 0);
devi2c.c:			d->salen = len;
devi2c.c:		}else if(cb->nf > 1 && strcmp(cb->f[0], "size") == 0){
devi2c.c:			len = strtol(cb->f[1], nil, 0);
devi2c.c:			d->tab[1].length = len;
devi2c.c:		}else if(strcmp(cb->f[0], "a10") == 0)
devi2c.c:			d->tenbit = 1;
devrtc3231.c:	/* Hours register may be in 12-hour or 24-hour mode */
devrtc3231.c:	switch((ulong)c->qid.path){
devrtc3231.c:		if(strcmp(up->user, eve)!=0 && omode!=OREAD)
devrtc3231.c:	if(c->qid.type & QTDIR)
devrtc3231.c:	switch((ulong)c->qid.path){
devrtc3231.c:	switch((ulong)c->qid.path){
devrtc3231.c:	for(i = 1970; i < rtc->year; i++){
devrtc3231.c:	d2m = yrsize(rtc->year);
devrtc3231.c:	for(i = 1; i < rtc->mon; i++)
devrtc3231.c:	secs += (rtc->mday-1) * SEC2DAY;
devrtc3231.c:	secs += rtc->hour * SEC2HOUR;
devrtc3231.c:	secs += rtc->min * SEC2MIN;
devrtc3231.c:	secs += rtc->sec;
devrtc3231.c:		day -= 1;
devrtc3231.c:	rtc->sec = hms % 60;
devrtc3231.c:	rtc->min = d % 60;
devrtc3231.c:	rtc->hour = d;
devrtc3231.c:			day -= *yrsize(d);
devrtc3231.c:		for (d = 1970; day < 0; d--)
devrtc3231.c:			day += *yrsize(d-1);
devrtc3231.c:	rtc->year = d;
devrtc3231.c:	d2m = yrsize(rtc->year);
devrtc3231.c:		day -= d2m[d];
devrtc3231.c:	rtc->mday = day + 1;
devrtc3231.c:	rtc->mon = d;
devspi.c:#define DEVID(path)	((ulong)path - Qspi)
devspi.c:	b = qget(spi->oq);
devspi.c:	spirw(spi->csel, b->rp, BLEN(b));
devspi.c:	qpass(spi->iq, b);
devspi.c:	if(c->qid.type & QTDIR)
devspi.c:	if(c->qid.path == Qctl) {
devspi.c:	spi = &spidev[DEVID(c->qid.path)];
devspi.c:	n = qread(spi->iq, a, n);
devspi.c:	if(c->qid.type & QTDIR)
devspi.c:	if(c->qid.path == Qctl) {
devspi.c:		switch(ct->index) {
devspi.c:			spiclock(atoi(cb->f[1]));
devspi.c:			spimode(atoi(cb->f[1]));
devspi.c:	spi = &spidev[DEVID(c->qid.path)];
devspi.c:	n = qwrite(spi->oq, a, n);
devspi.c:	if(c->qid.type & QTDIR)
devspi.c:	spi = &spidev[DEVID(c->qid.path)];
devspi.c:	if(spi->opens++ == 0){
devspi.c:		spi->csel = DEVID(c->qid.path);
devspi.c:		if(spi->iq == nil)
devspi.c:			spi->iq = qopen(QMAX, 0, nil, nil);
devspi.c:			qreopen(spi->iq);
devspi.c:		if(spi->oq == nil)
devspi.c:			spi->oq = qopen(QMAX, Qkick, spikick, spi);
devspi.c:			qreopen(spi->oq);
devspi.c:	c->iounit = qiomaxatomic;
devspi.c:	if(c->qid.type & QTDIR)
devspi.c:	if((c->flag & COPEN) == 0)
devspi.c:	spi = &spidev[DEVID(c->qid.path)];
devspi.c:	if(--spi->opens == 0){
devspi.c:		qclose(spi->iq);
devspi.c:		qhangup(spi->oq, nil);
devspi.c:		qclose(spi->oq);
dma.c: * simplest to use only channels 0-6
dma.c: *	channels 7-14 have reduced functionality
dma.c: * Experiments show that only channels 2-5,11-12 work with mmc
dma.c:	Cbalign		= 64,		/* control block byte alignment (allow for 64-byte cache on bcm2836) */
dma.c:	while(n-- > 0)
dma.c:	return ((Ctlr*)a)->dmadone;
dma.c:	ctlr->regs[Cs] = Int;
dma.c:	ctlr->dmadone = 1;
dma.c:	wakeup(&ctlr->r);
dma.c:	if(ctlr->regs == nil){
dma.c:		ctlr->regs = (u32int*)(DMAREGS + chan*Regsize);
dma.c:		ctlr->cb = xspanalloc(sizeof(Cb), Cbalign, 0);
dma.c:		assert(ctlr->cb != nil);
dma.c:		ctlr->regs[Cs] = Reset;
dma.c:		while(ctlr->regs[Cs] & Reset)
dma.c:	cb = ctlr->cb;
dma.c:		cb->sourcead = dmaioaddr(src);
dma.c:		cb->destad = dmaaddr(dst);
dma.c:		cb->sourcead = dmaaddr(src);
dma.c:		cb->destad = dmaioaddr(dst);
dma.c:		cb->sourcead = dmaaddr(src);
dma.c:		cb->destad = dmaaddr(dst);
dma.c:	cb->ti = ti | dev<<Permapshift | Inten;
dma.c:	cb->txfrlen = len;
dma.c:	cb->stride = 0;
dma.c:	cb->nextconbk = 0;
dma.c:	ctlr->regs[Cs] = 0;
dma.c:	ctlr->regs[Conblkad] = dmaaddr(cb);
dma.c:		cb->ti, cb->sourcead, cb->destad, cb->txfrlen,
dma.c:		cb->stride, cb->nextconbk);
dma.c:	ctlr->regs[Cs] = Int;
dma.c:	DBG dumpdregs("before Active", ctlr->regs);
dma.c:	ctlr->regs[Cs] = Active;
dma.c:	DBG dumpdregs("after Active", ctlr->regs);
dma.c:	tsleep(&ctlr->r, dmadone, ctlr, 3000);
dma.c:	ctlr->dmadone = 0;
dma.c:	r = ctlr->regs;
dma.c:		return -1;
emmc.c:	WR(Control1, clkdiv(emmc.extclk/Initfreq - 1) |
emmc.c:	now = m->ticks;
emmc.c:		if(m->ticks-now > HZ)
emmc.c:		WR(Control1, clkdiv(emmc.extclk/SDfreq - 1) |
etherusb.c:		print(" %2.2ux", b->rp[i]);
etherusb.c:	ctlr = edev->ctlr;
etherusb.c:		ctlr->rxpkt++;
etherusb.c:		memmove(nb->wp, b->rp, m);
etherusb.c:		nb->wp += m;
etherusb.c:		ctlr->rxpkt++;
etherusb.c:		edev->soverflows++;
etherusb.c:	b->rp += m;
etherusb.c:		return -1;
etherusb.c:		return -1;
etherusb.c:	hd = GET4(b->rp);
etherusb.c:	b->rp += 4;
etherusb.c:		return -1;
etherusb.c:		return -1;
etherusb.c:	if((wp = b->rp + m) != b->wp && b->wp - wp < 4)
etherusb.c:		b->wp = wp;
etherusb.c:		return -1;
etherusb.c:	hd = GET4(b->rp);
etherusb.c:	b->rp += 4;
etherusb.c:		return -1;
etherusb.c:	if(BLEN(b) - m < 4)
etherusb.c:		b->wp = b->rp + m;
etherusb.c:		edev->frames++;
etherusb.c:		b->rp += m;
etherusb.c:		b->rp += 4 - m;
etherusb.c:	c = ctlr->outchan;
etherusb.c:	devtab[c->type]->bwrite(c, b, 0);
etherusb.c:	PUT4(b->rp, n);
etherusb.c:	if(BLEN(b) % ctlr->maxpkt == 0){
etherusb.c:		b = padblock(b, -4);
etherusb.c:		PUT4(b->wp, 0xFFFF0000);
etherusb.c:		b->wp += 4;
etherusb.c:	PUT4(b->rp, n | SmscTxfirst | SmscTxlast);
etherusb.c:	PUT4(b->rp+4, n);
etherusb.c:	ctlr = edev->ctlr;
etherusb.c:	c = ctlr->inchan;
etherusb.c:		print("etherusbproc: error exit %s\n", up->errstr);
etherusb.c:		pexit(up->errstr, 1);
etherusb.c:			b = devtab[c->type]->bread(c, ctlr->bufsize, 0);
etherusb.c:			ctlr->rxbuf++;
etherusb.c:		switch(ctlr->udev->unpack(edev, b)){
etherusb.c:		case -1:
etherusb.c:			edev->buffs++;
etherusb.c:	if(ctlr->buf != nil)
etherusb.c:	maxpkt = strtol(cb->f[6], 0, 0);
etherusb.c:	bufsize = strtol(cb->f[5], 0, 0);
etherusb.c:	inchan = namec(cb->f[2], Aopen, OREAD, 0);
etherusb.c:	outchan = namec(cb->f[3], Aopen, OWRITE, 0);
etherusb.c:	if(parsemac(ea, cb->f[4], Eaddrlen) != Eaddrlen)
etherusb.c:	if(memcmp(ctlr->edev->ea, nullea, Eaddrlen) == 0)
etherusb.c:		memmove(ctlr->edev->ea, ea, Eaddrlen);
etherusb.c:	else if(memcmp(ctlr->edev->ea, ea, Eaddrlen) != 0)
etherusb.c:	memmove(ctlr->edev->addr, ea, Eaddrlen);
etherusb.c:	print("\netherusb %s: %E\n", udev->name, ctlr->edev->addr);
etherusb.c:	ctlr->buf = buf;
etherusb.c:	ctlr->inchan = inchan;
etherusb.c:	ctlr->outchan = outchan;
etherusb.c:	ctlr->bufsize = bufsize;
etherusb.c:	ctlr->maxpkt = maxpkt;
etherusb.c:	ctlr->udev = udev;
etherusb.c:	kproc("etherusb", etherusbproc, ctlr->edev);
etherusb.c:	if(ctlr->buf != nil){
etherusb.c:		free(ctlr->buf);
etherusb.c:		ctlr->buf = nil;
etherusb.c:		if(ctlr->inchan)
etherusb.c:			cclose(ctlr->inchan);
etherusb.c:		if(ctlr->outchan)
etherusb.c:			cclose(ctlr->outchan);
etherusb.c:		ctlr->inchan = ctlr->outchan = nil;
etherusb.c:	ctlr = edev->ctlr;
etherusb.c:	l += snprint(p+l, READSTR-l, "rxbuf: %ud\n", ctlr->rxbuf);
etherusb.c:	l += snprint(p+l, READSTR-l, "rxpkt: %ud\n", ctlr->rxpkt);
etherusb.c:	l += snprint(p+l, READSTR-l, "txbuf: %ud\n", ctlr->txbuf);
etherusb.c:	l += snprint(p+l, READSTR-l, "txpkt: %ud\n", ctlr->txpkt);
etherusb.c:	ctlr = edev->ctlr;
etherusb.c:	while((b = qget(edev->oq)) != nil){
etherusb.c:		ctlr->txpkt++;
etherusb.c:		if(ctlr->buf == nil)
etherusb.c:			ctlr->udev->transmit(ctlr, b);
etherusb.c:			ctlr->txbuf++;
etherusb.c:	if((ctlr = edev->ctlr) == nil)
etherusb.c:	switch(ct->index){
etherusb.c:		for(udev = udevtab; udev->name; udev++)
etherusb.c:			if(strcmp(cb->f[1], udev->name) == 0)
etherusb.c:		if(udev->name == nil)
etherusb.c:	ctlr = edev->ctlr;
etherusb.c:	ctlr->edev = edev;
etherusb.c:	edev->ctlr = ctlr;
etherusb.c:	edev->irq = -1;
etherusb.c:	edev->mbps = 100;	/* TODO: get this from usbether */
etherusb.c:	edev->attach = etherusbattach;
etherusb.c:	edev->transmit = etherusbtransmit;
etherusb.c:	edev->interrupt = nil;
etherusb.c:	edev->ifstat = etherusbifstat;
etherusb.c:	edev->ctl = etherusbctl;
etherusb.c:	edev->arg = edev;
etherusb.c://	edev->promiscuous = etherusbpromiscuous;
etherusb.c:	edev->shutdown = etherusbshutdown;
etherusb.c:	edev->multicast = etherusbmulticast;
fpiarm.c: * this doesn't attempt to implement ARM floating-point properties
fpiarm.c:#define ARM7500			/* emulate old pre-VFP opcodes */
fpiarm.c:#define	FR(ufp, x) (*(Internal*)(ufp)->regs[(x)&7])
fpiarm.c:#define	FR(ufp, x) (*(Internal*)(ufp)->regs[(x)&(Nfpregs - 1)])
fpiarm.c:#define	OFR(X)	((ulong)&((Ureg*)0)->X)
fpiarm.c:	d->s ^= 1;
fpiarm.c:	d->s = 0;
fpiarm.c:	(m->s? fsub: fadd)(fpconst[6], *m, d);
fpiarm.c:	e = (d->e - ExpBias) + 1;
fpiarm.c:			d->l &= ~((1<<(2*FractBits - e))-1);
fpiarm.c:		d->l = 0;
fpiarm.c:			d->h &= ~((1<<(FractBits-e))-1);
fpiarm.c:			off = -off;
fpiarm.c:				ur->psr &= ~(N|C|Z|V);
fpiarm.c:				ur->psr |= fcmp(fn, fm);
fpiarm.c:			case 5:	/* CNF: Fn :: -Fm */
fpiarm.c:			case 7:	/* CNFE: Fn :: -Fm (with exception) */
fpiarm.c:				ur->psr &= ~(N|C|Z|V);
fpiarm.c:				ur->psr |= fcmp(fn, &tmp);
fpiarm.c:					tag, rn, op&7, ur->psr>>28);
fpiarm.c:			ufp->status = REG(ur, rd);
fpiarm.c:			REG(ur, rd) = ufp->status;
fpiarm.c:			ufp->control = REG(ur, rd);
fpiarm.c:			REG(ur, rd) = ufp->control;
fpiarm.c:		if(fp->f == nil)
fpiarm.c:			print("%s	%c%ld,F%d\n", fp->name, tag, op&7, rd);
fpiarm.c:		(*fp->f)(fm, &FR(ufp, rd));
fpiarm.c:		if(fp->f == nil)
fpiarm.c:			print("%s	%c%ld,F%d,F%d\n", fp->name, tag, op&7, rn, rd);
fpiarm.c:		(*fp->f)(*fm, FR(ufp, rn), &FR(ufp, rd));
fpiarm.c:	ufp = &up->fpsave;
fpiarm.c:	switch(up->fpstate){
fpiarm.c:		assert(sizeof(Internal) <= sizeof(ufp->regs[0]));
fpiarm.c:		up->fpstate = FPemu;
fpiarm.c:		ufp->control = 0;
fpiarm.c:		ufp->status = (0x01<<28)|(1<<12); /* sw emulation, alt. C flag */
fpiarm.c:		validaddr(ur->pc, 4, 0);
fpiarm.c:		op = *(ulong*)(ur->pc);
fpiarm.c:			print("%#lux: %#8.8lux ", ur->pc, op);
fpiarm.c:		if(condok(ur->psr, op>>28))
fpiarm.c:			fpemu(ur->pc, op, ur, ufp);
fpiarm.c:		ur->pc += 4;		/* pretend cpu executed the instr */
i2c.c: * Per-controller info
i2c.c:	if((r->ctrl & Intr) && (r->stat & Rxd))
i2c.c:	if((r->ctrl & Intt) && (r->stat & Txd))
i2c.c:	if(r->stat & Done)
i2c.c:		r->ctrl &= ~st;
i2c.c:	return (i2c.regs->stat & (uintptr)st);
i2c.c:	i2c.regs->clkdiv = 2500;
i2c.c: * 	- write the subaddress,
i2c.c: *	- poll until the transfer starts,
i2c.c: *	- overwrite the registers for the payload transfer, before the subaddress
i2c.c:	r->ctrl = I2cen | Clear;
i2c.c:	r->addr = addr;
i2c.c:	r->stat = Clkt|Err|Done;
i2c.c:		r->dlen = salen;
i2c.c:		r->ctrl = I2cen | Start | Write;
i2c.c:		while((r->stat & Ta) == 0) {
i2c.c:			if(r->stat & (Err|Clkt)) {
i2c.c:		r->dlen = len;
i2c.c:		r->ctrl = I2cen | Start | Intd | rw;
i2c.c:		for(; salen > 0; salen--)
i2c.c:			r->fifo = subaddr >> ((salen-1)*8);
i2c.c:				if(r->stat & (Err|Clkt)) {
i2c.c:				st = r->stat >> 28;
i2c.c:		r->dlen = len;
i2c.c:		r->ctrl = I2cen | Start | Intd | rw;
i2c.c:		while((r->stat & (st|Done)) == 0){
i2c.c:			r->ctrl |= rw == Read? Intr : Intt;
i2c.c:		if(r->stat & (Err|Clkt)){
i2c.c:				*p++ = r->fifo;
i2c.c:				len--;
i2c.c:			}while ((r->stat & Rxd) && len > 0);
i2c.c:				r->fifo = *p++;
i2c.c:				len--;
i2c.c:			}while((r->stat & Txd) && len > 0);
i2c.c:	while((r->stat & Done) == 0)
i2c.c:	if(r->stat & (Err|Clkt)){
i2c.c:	r->ctrl = 0;
i2c.c:	i2cio(Write, d->tenbit, d->addr, buf, len, d->salen, offset);
i2c.c:	i2cio(Read, d->tenbit, d->addr, buf, len, d->salen, offset);
main.c:	/* space for syscall args, return PC, top-of-stack struct */
main.c:#define	BOOTARGSLEN	(MACHADDR-CONFADDR)
main.c:static uintptr sp;		/* XXX - must go - user stack of init proc */
main.c:		u32int	data[1];	/* actually [size-2] */
main.c:		char	cmdline[1];	/* actually [4*(size-2)] */
main.c:	return -1;
main.c:	n = q - p + 1;
main.c:	memset(BOOTARGS + n, '\n', BOOTARGSLEN - n);
main.c:	if(a->tag != AtagCore){
main.c:	while(a->tag != AtagNone){
main.c:		switch(a->tag){
main.c:			if(conf.mem[0].limit == 0 && a->mem.size != 0){
main.c:				memsize = a->mem.size;
main.c:				conf.mem[0].base = a->mem.base;
main.c:				conf.mem[0].limit = a->mem.base + memsize;
main.c:			n = (a->size * sizeof(u32int)) - offsetof(Atag, cmdline[0]);
main.c:			if(a->cmdline + n < BOOTARGS + BOOTARGSLEN)
main.c:				a->cmdline[n] = 0;
main.c:				BOOTARGS[BOOTARGSLEN-1] = 0;
main.c:			plan9iniinit(a->cmdline, 1);
main.c:		a = (Atag*)((u32int*)a + a->size);
main.c:		conf.nmach--;
main.c:	m->ticks = 1;
main.c:	m->perf.period = 1;
main.c:	if (m->machno != 0) {
main.c:		m->ticks = m0->ticks;
main.c:	m->machno = 0;
main.c:	machaddr[m->machno] = m;
main.c:		mm->machno = mach;
main.c:		memmove(l1, m->mmul1, L1SIZE);  /* clone cpu0's l1 table */
main.c:		mm->mmul1 = l1;
main.c:	oargc = tokenize(oargb, oargv, nelem(oargv)-1);
main.c:	memset(edata, 0, end - edata);	/* clear bss */
main.c:	m->mmul1 = (PTE*)L1;
main.c:	up->nerrlab = 0;
main.c:	up->slash = namec("#/", Atodir, 0, 0);
main.c:	pathclose(up->slash->path);
main.c:	up->slash->path = newpath("/");
main.c:	up->dot = cclone(up->slash);
main.c:		snprint(buf, sizeof(buf), "-a %s", getethermac());
main.c:				devtab[c->type]->write(c, "init", 4, 0);
main.c:	p = UINT2PTR(STACKALIGN(base + BY2PG - Ustkheadroom - i));
main.c:	av = (char**)(p - (oargc+1)*sizeof(char*));
main.c:	ssize = base + BY2PG - PTR2UINT(av);
main.c:		*av++ = (oargv[i] - oargb) + (p - base) + (USTKTOP - BY2PG);
main.c:	sp = USTKTOP - ssize;
main.c:	p->pgrp = newpgrp();
main.c:	p->egrp = smalloc(sizeof(Egrp));
main.c:	p->egrp->ref = 1;
main.c:	p->fgrp = dupfgrp(nil);
main.c:	p->rgrp = newrgrp();
main.c:	p->procmode = 0640;
main.c:	kstrdup(&p->text, "*init*");
main.c:	kstrdup(&p->user, eve);
main.c:	p->sched.pc = PTR2UINT(init0);
main.c:	p->sched.sp = PTR2UINT(p->kstack+KSTACK-sizeof(up->s.args)-sizeof(uintptr));
main.c:	p->sched.sp = STACKALIGN(p->sched.sp);
main.c:	s = newseg(SG_STACK, USTKTOP-USTKSIZE, USTKSIZE/BY2PG);
main.c:	s->flushme++;
main.c:	p->seg[SSEG] = s;
main.c:	pg = newpage(1, 0, USTKTOP-BY2PG);
main.c:	p->seg[TSEG] = s;
main.c:	pg->txtflush = ~0;
main.c:	k = kmap(s->map[0]->pages[0]);
main.c:		memsize = strtoul(p, 0, 0) - PHYSDRAM;
main.c:		conf.mem[i].npage = (conf.mem[i].limit - conf.mem[i].base)/BY2PG;
main.c:	conf.ialloc = ((conf.npage-conf.upages)/2)*BY2PG;
main.c:	kpages = conf.npage - conf.upages;
main.c:	kpages -= conf.upages*sizeof(Page)
main.c:	mainmem->maxsize = kpages;
main.c:		 * be careful with 32-bit overflow.
main.c:		imagmem->maxsize = kpages;
main.c:	else if(m->machno == 0 && (active.machs[m->machno] == 0))
main.c:	once = active.machs[m->machno];
main.c:	active.machs[m->machno] = (once + 1) % 2;
main.c:		delay(m->machno*100);		/* stagger them */
main.c:		iprint("cpu%d: exiting\n", m->machno);
main.c:	if (m->machno == 0)
main.c:	for(; ms > 0; ms -= TK2MS(2)){
main.c:	if(m->machno == 0)
main.c:	isa->type = "";
main.c:	isa->nopt = tokenize(p, isa->opt, NISAOPT);
main.c:	for(i = 0; i < isa->nopt; i++){
main.c:		p = isa->opt[i];
main.c:			isa->type = p + 5;
main.c:	if (m->machno != 0) {
main.c:	if (m->machno != 0)
main.c:		print("on cpu%d (not 0)!\n", m->machno);
main.c:	/* off we go - never to return */
mmu.c:#define FEXT(d, o, w) (((d)>>(o)) & ((1<<(w))-1))
mmu.c:	L1hi		= (USTKTOP+MiB-1)/MiB,	/* L1X(USTKTOP+MiB-1)? */
mmu.c:	l1 = m->mmul1;
mmu.c:	l1 = m->mmul1;
mmu.c:	l2 = &proc->mmul2;
mmu.c:	for(page = *l2; page != nil; page = page->next){
mmu.c:			memset(UINT2PTR(page->va), 0, L2size);
mmu.c:		l1[page->daddr] = Fault;
mmu.c:		l2 = &page->next;
mmu.c:	*l2 = proc->mmul2cache;
mmu.c:	proc->mmul2cache = proc->mmul2;
mmu.c:	proc->mmul2 = nil;
mmu.c:	if(m->mmul1lo > 0){
mmu.c:		if(m->mmul1lo == 1)
mmu.c:			m->mmul1[L1lo] = Fault;
mmu.c:			memset(&m->mmul1[L1lo], 0, m->mmul1lo*sizeof(PTE));
mmu.c:		m->mmul1lo = 0;
mmu.c:	if(m->mmul1hi > 0){
mmu.c:		l1 = &m->mmul1[L1hi - m->mmul1hi];
mmu.c:		if(m->mmul1hi == 1)
mmu.c:			memset(l1, 0, m->mmul1hi*sizeof(PTE));
mmu.c:		m->mmul1hi = 0;
mmu.c:	if(proc != nil && proc->newtlb){
mmu.c:		proc->newtlb = 0;
mmu.c:	l1 = m->mmul1;
mmu.c:	for(page = proc->mmul2; page != nil; page = page->next){
mmu.c:		x = page->daddr;
mmu.c:		l1[x] = PPN(page->pa)|Dom0|Coarse;
mmu.c:		if(x >= L1lo + m->mmul1lo && x < L1hi - m->mmul1hi){
mmu.c:			if(x+1 - L1lo < L1hi - x)
mmu.c:				m->mmul1lo = x+1 - L1lo;
mmu.c:				m->mmul1hi = L1hi - x;
mmu.c:	cachedwbtlb(&l1[L1X(UZERO)], (L1hi - L1lo)*sizeof(PTE));
mmu.c:	up->newtlb = 1;
mmu.c:	for(page = proc->mmul2cache; page != nil; page = next){
mmu.c:		next = page->next;
mmu.c:		if(--page->ref)
mmu.c:			panic("mmurelease: page->ref %lud", page->ref);
mmu.c:	if(proc->mmul2cache != nil)
mmu.c:	proc->mmul2cache = nil;
mmu.c:	cachedwbtlb(&m->mmul1[L1X(UZERO)], (L1hi - L1lo)*sizeof(PTE));
mmu.c:	l1 = &m->mmul1[x];
mmu.c:		/* l2 pages only have 256 entries - wastes 3K per 1M of address space */
mmu.c:		if(up->mmul2cache == nil){
mmu.c:			l1 = &m->mmul1[x];
mmu.c:			pg->va = VA(kmap(pg));
mmu.c:			pg = up->mmul2cache;
mmu.c:			up->mmul2cache = pg->next;
mmu.c:		pg->daddr = x;
mmu.c:		pg->next = up->mmul2;
mmu.c:		up->mmul2 = pg;
mmu.c:		cachedwbtlb((void *)pg->va, L2size);
mmu.c:		*l1 = PPN(pg->pa)|Dom0|Coarse;
mmu.c:		if(x >= L1lo + m->mmul1lo && x < L1hi - m->mmul1hi){
mmu.c:			if(x+1 - L1lo < L1hi - x)
mmu.c:				m->mmul1lo = x+1 - L1lo;
mmu.c:				m->mmul1hi = L1hi - x;
mmu.c:	if(page->txtflush){
mmu.c:		page->txtflush = 0;
mmu.c:	assert(!(va & (1*MiB-1)) && size == 1*MiB);
mmu.c:	pte = &m->mmul1[x];
mmu.c:		return PHYSDRAM + memsize - pa;
mmu.c:	assert((va & (MiB-1)) == 0);
mmu.c:	o = pa & (MiB-1);
mmu.c:	pa -= o;
mmu.c:	pte = pte0 = &m->mmul1[L1X(va)];
mmu.c:	cachedwbtlb(pte0, (uintptr)pte - (uintptr)pte0);
mmu.c:	l1 = &m->mmul1[x];
mmu.c:		iprint("checkmmu cpu%d va=%lux l1 %p=%ux\n", m->machno, va, l1, *l1);
pitft.c:	if(qproduce(updateq, &r, sizeof(Rectangle)) == -1) {
pitft.c:			bb.max.x-1, bb.max.y-1);
pitft.c:		bb.max.y = -1;
pitft.c:			if(bb.max.y != -1) {
screen.c:		set = curs->set[i];
screen.c:		clr = curs->clr[i];
screen.c:	swoffset = curs->offset;
screen.c:	memimagedraw(swimg1,  swimg1->r,  swimg,  ZP, memopaque, ZP, S);
screen.c:	memimagedraw(swmask1, swmask1->r, swmask, ZP, memopaque, ZP, S);
screen.c:	if((dst=par->dst) == nil || dst->data == nil)
screen.c:	if((src=par->src) == nil || src->data == nil)
screen.c:	if((mask=par->mask) == nil || mask->data == nil)
screen.c:	if(dst->data->bdata == xgdata.bdata)
screen.c:		swcursoravoid(par->r);
screen.c:	if(src->data->bdata == xgdata.bdata)
screen.c:		swcursoravoid(par->sr);
screen.c:	if(mask->data->bdata == xgdata.bdata)
screen.c:		swcursoravoid(par->mr);
screen.c:		lcd->draw(par->r);
screen.c:		return -1;
screen.c:		return -1;
screen.c:	gscreen->width = wordsperline(gscreen->r, gscreen->depth);
screen.c:	*r = gscreen->r;
screen.c:	*d = gscreen->depth;
screen.c:	*chan = gscreen->chan;
screen.c:	*width = gscreen->width;
screen.c:	return gscreen->data->bdata;
screen.c:		lcd->blank(blank);
screen.c:			--n;
screen.c:		n -= i;
screen.c:	orange->flags |= Frepl;
screen.c:	orange->clipr = gscreen->r;
screen.c:	orange->data->bdata[0] = 0x40;		/* magic: colour? */
screen.c:	orange->data->bdata[1] = 0xfd;		/* magic: colour? */
screen.c:	w = memdefont->info[' '].width;
screen.c:	h = memdefont->height;
screen.c:	r = insetrect(gscreen->r, 4);
screen.c:	window.max.y = window.min.y + ((window.max.y - window.min.y) / h) * h;
screen.c:	r = Rpt(window.min, Pt(window.max.x, window.max.y-o));
screen.c:		lcd->draw(r);
screen.c:	r = Rpt(Pt(window.min.x, window.max.y-o), window.max);
screen.c:		lcd->draw(r);
screen.c:	curpos.y -= o;
screen.c:		if (curpos.x >= window.max.x - Tabstop * w)
screen.c:		pos = (curpos.x - window.min.x) / w;
screen.c:		pos = Tabstop - pos % Tabstop;
screen.c:		memimagedraw(gscreen, r, back, back->r.min, nil, back->r.min, S);
screen.c:		xp--;
screen.c:		memimagedraw(gscreen, r, back, back->r.min, nil, back->r.min, S);
screen.c:		if (curpos.x >= window.max.x - w)
screen.c:		memimagedraw(gscreen, r, back, back->r.min, nil, back->r.min, S);
spi.c: * Per-controller info
spi.c:	spi.regs->clkdiv = 250;		/* 1 MHz */
spi.c:	spi.regs->cs = (spi.regs->cs & ~(Cpha | Cpol)) | (mode << 2);
spi.c:		spi.regs->clkdiv = 32768;	/* about 8 KHz */
spi.c:	spi.regs->clkdiv = 2 * ((125 + (mhz - 1)) / mhz);
spi.c:	r->dlen = len;
spi.c:	r->cs = (cs << Csshift) | Rxclear | Txclear | Dmaen | Adcs | Ta;
spi.c:	 * Start write channel before read channel - cache wb before inv
spi.c:		buf, &r->data, len);
spi.c:		&r->data, buf, len);
spi.c:	r->cs = 0;
trap.c:	if (m->machno == 0) {
trap.c:		memmove(vpage0->vectors, vectors, sizeof(vpage0->vectors));
trap.c:		memmove(vpage0->vtable, vtable, sizeof(vpage0->vtable));
trap.c:	setr13(PsrMirq, m->sirq);
trap.c:	setr13(PsrMabt, m->sabt);
trap.c:	setr13(PsrMund, m->sund);
trap.c:	setr13(PsrMsys, m->ssys);
trap.c:	enable = (u32int*)(LOCALREGS + Localtimerint) + m->machno;
trap.c:	if(m->machno){
trap.c:		enable = (u32int*)(LOCALREGS + Localmboxint) + m->machno;
trap.c:	ip->GPUdisable[0] = disable;
trap.c:	ip->GPUdisable[1] = disable;
trap.c:	ip->ARMdisable = disable;
trap.c:	ip->FIQctl = 0;
trap.c:	diff = x - m->perf.intrts;
trap.c:	m->perf.intrts = 0;
trap.c:	m->perf.inintr += diff;
trap.c:	if(up == nil && m->perf.inidle > diff)
trap.c:		m->perf.inidle -= diff;
trap.c:	m->perf.intrts = perfticks();
trap.c:	for(v = vctl; v; v = v->next)
trap.c:		if(v->cpu == m->machno && (*v->reg & v->mask) != 0){
trap.c:			v->f(ureg, v->a);
trap.c:			if(v->irq == IRQclock || v->irq == IRQcntps || v->irq == IRQcntpns)
trap.c:		m->spuriousintr++;
trap.c:	if(m->perf.intrts)
trap.c:		m->perf.intrts = perfticks();
trap.c:		panic("cpu%d: unexpected item in bagging area", m->machno);
trap.c:	m->intr++;
trap.c:	ureg->pc -= 4;
trap.c:	v->f(ureg, v->a);
trap.c:	v->irq = irq;
trap.c:	v->cpu = 0;
trap.c:		v->reg = (u32int*)(LOCALREGS + Localintpending) + m->machno;
trap.c:			enable = (u32int*)(LOCALREGS + Localmboxint) + m->machno;
trap.c:			enable = (u32int*)(LOCALREGS + Localtimerint) + m->machno;
trap.c:		v->mask = 1 << (irq - IRQlocal);
trap.c:		v->cpu = m->machno;
trap.c:		enable = &ip->ARMenable;
trap.c:		v->reg = &ip->ARMpending;
trap.c:		v->mask = 1 << (irq - IRQbasic);
trap.c:		enable = &ip->GPUenable[irq/32];
trap.c:		v->reg = &ip->GPUpending[irq/32];
trap.c:		v->mask = 1 << (irq % 32);
trap.c:	v->f = f;
trap.c:	v->a = a;
trap.c:		assert((ip->FIQctl & Fiqenable) == 0);
trap.c:		assert((*enable & v->mask) == 0);
trap.c:		ip->FIQctl = Fiqenable | irq;
trap.c:		v->next = vctl;
trap.c:				*enable |= 1 << (irq - IRQmbox0);
trap.c:			*enable |= 1 << (irq - IRQlocal);
trap.c:			*enable = v->mask;
trap.c:	if (va == lastva && up->pid == lastpid) {
trap.c:		lastpid = up->pid;
trap.c:		panic("fault: nil up in faultarm, pc %#p accessing %#p", ureg->pc, va);
trap.c:	insyscall = up->insyscall;
trap.c:	up->insyscall = 1;
trap.c:	up->insyscall = insyscall;
trap.c:		rem = ((char*)ureg)-up->kstack;
trap.c:		rem = ((char*)ureg)-((char*)m+sizeof(Mach));
trap.c:			rem, up, ureg, ureg->pc);
trap.c:			rem, up, ureg, ureg->pc);
trap.c:	user = (ureg->psr & PsrMask) == PsrMusr;
trap.c:		up->dbgreg = ureg;
trap.c:		cycles(&up->kentry);
trap.c:	 * All interrupts/exceptions should be resumed at ureg->pc-4,
trap.c:	 * except for Data Abort which resumes at ureg->pc-8.
trap.c:	if(ureg->type == (PsrMabt+1))
trap.c:		ureg->pc -= 8;
trap.c:		ureg->pc -= 4;
trap.c:	switch(ureg->type){
trap.c:		panic("unknown trap; type %#lux, psr mode %#lux pc %lux", ureg->type,
trap.c:			ureg->psr & PsrMask, ureg->pc);
trap.c:		m->intr++;
trap.c:					ureg->pc, *(u32int*)ureg->pc);
trap.c:			faultarm(ureg, ureg->pc, user, 1);
trap.c:		inst = *(ulong*)(ureg->pc);
trap.c:			panic("vector exception at %#lux", ureg->pc);
trap.c:					ureg->pc, va);
trap.c:				panic("kernel alignment: pc %#lux va %#p", ureg->pc, va);
trap.c:			panic("terminal exception at %#lux", ureg->pc);
trap.c:		case 0x8:		/* precise external abort, non-xlat'n */
trap.c:		case 0x16:		/* imprecise ext. abort, non-xlt'n */
trap.c:				fsr, ureg->pc, va);
trap.c:				fsr, ureg->pc, va);
trap.c:					ureg->pc, va);
trap.c:					ureg->pc, va);
trap.c:			if(seg(up, ureg->pc, 0) != nil &&
trap.c:			   *(u32int*)ureg->pc == 0xD1200070)
trap.c:						ureg->pc);
trap.c:			if (ureg->pc & 3) {
trap.c:					ureg->pc);
trap.c:				ureg->pc &= ~3;
trap.c:				ureg->pc, *(u32int*)ureg->pc);
trap.c:	if(up && up->delaysched && clockintr){
trap.c:		if(up->procctl || up->nnote)
trap.c:		ureg->pc, ureg->sp, ureg->r14);
trap.c:	if(up != nil && (uintptr)&l <= (uintptr)up->kstack+KSTACK)
trap.c:		estack = (uintptr)up->kstack+KSTACK;
trap.c:	else if((uintptr)&l >= (uintptr)m->stack
trap.c:			iprint("&up->kstack %#p &l %#p\n", up->kstack, &l);
trap.c:			v -= sizeof(u32int);		/* back up an instr */
trap.c:	*sp = (ulong)&pc-4;
trap.c:	iprint("trap: %s", trapname(ureg->type));
trap.c:	if(ureg != nil && (ureg->psr & PsrMask) != PsrMsvc)
trap.c:		iprint(" in %s", trapname(ureg->psr));
trap.c:		ureg->psr, ureg->type, ureg->pc, ureg->link);
trap.c:		ureg->r14, ureg->r13, ureg->r12, ureg->r11, ureg->r10);
trap.c:		ureg->r9, ureg->r8, ureg->r7, ureg->r6, ureg->r5);
trap.c:		ureg->r4, ureg->r3, ureg->r2, ureg->r1, ureg->r0);
trap.c:	iprint("pc %#lux link %#lux\n", ureg->pc, ureg->link);
trap.c:		iprint("user stack: %#p-%#p\n", up->kstack, up->kstack+KSTACK-4);
trap.c:		iprint("kernel stack: %8.8lux-%8.8lux\n",
trap.c:			(ulong)(m+1), (ulong)m+BY2PG-4);
uartmini.c:	ap = (u32int*)uart->regs;
uartmini.c:		//if(uart->console){
uartmini.c:		//	if(uart->opens == 1)
uartmini.c:		//		uart->putc = kbdcr2nl;
uartmini.c:		//		uart->putc = nil;
uartmini.c:	//if(uart->console == 0)
uartmini.c:	ap = (u32int*)uart->regs;
uartmini.c:	ap[MuBaud] = uart->freq/(115200*8) - 1;
uartmini.c:	ap = (u32int*)uart->regs;
uartmini.c:	ap = (u32int*)uart->regs;
uartmini.c:	if(uart->blocked)
uartmini.c:		if(uart->op >= uart->oe && uartstageoutput(uart) == 0)
uartmini.c:		ap[MuIo] = *(uart->op++);
uartmini.c:	ap = (u32int*)uart->regs;
uartmini.c:	if(uart->freq == 0 || n <= 0)
uartmini.c:		return -1;
uartmini.c:	ap[MuBaud] = (uart->freq + 4*n - 1) / (8 * n) - 1;
uartmini.c:	uart->baud = n;
uartmini.c:	ap = (u32int*)uart->regs;
uartmini.c:		return -1;
uartmini.c:	uart->bits = n;
uartmini.c:		return -1;
uartmini.c:	uart->stop = n;
uartmini.c:		return -1;
uartmini.c:	uart->parity = n;
uartmini.c:	ap = (u32int*)uart->regs;
uartmini.c:	uart->modem = on;
uartmini.c:	ap = (u32int*)uart->regs;
uartmini.c:		uart->baud,
uartmini.c:		uart->dev,
uartmini.c:		uart->type,
uartmini.c:		uart->ferr,
uartmini.c:		uart->oerr,
uartmini.c:		uart->berr,
uartmini.c:		uart->serr
uartmini.c:	if(!uart->enabled)
uartmini.c:		(*uart->phys->enable)(uart, 0);
uartmini.c:	uart->console = 1;
usbdwc.c: * - no isochronous pipes
usbdwc.c: * - no bandwidth budgeting
usbdwc.c: * - frame scheduling is crude
usbdwc.c: * - error handling is overly optimistic
usbdwc.c:	ulong	chanbusy;	/* bitmap of in-use channels */
usbdwc.c:	l->sr = x;
usbdwc.c:	ctlr = ep->hp->aux;
usbdwc.c:	qlock(&ctlr->chanlock);
usbdwc.c:	bitmap = ctlr->chanbusy;
usbdwc.c:	for(i = 0; i < ctlr->nchan; i++)
usbdwc.c:			ctlr->chanbusy = bitmap | 1<<i;
usbdwc.c:			qunlock(&ctlr->chanlock);
usbdwc.c:			return &ctlr->regs->hchan[i];
usbdwc.c:	qunlock(&ctlr->chanlock);
usbdwc.c:	ctlr = ep->hp->aux;
usbdwc.c:	i = chan - ctlr->regs->hchan;
usbdwc.c:	qlock(&ctlr->chanlock);
usbdwc.c:	ctlr->chanbusy &= ~(1<<i);
usbdwc.c:	qunlock(&ctlr->chanlock);
usbdwc.c:	Ctlr *ctlr = ep->hp->aux;
usbdwc.c:	if(ep->debug)
usbdwc.c:		ctlr->debugchan |= 1 << (hc - ctlr->regs->hchan);
usbdwc.c:		ctlr->debugchan &= ~(1 << (hc - ctlr->regs->hchan));
usbdwc.c:	switch(ep->dev->state){
usbdwc.c:		hcc = ep->dev->nb<<ODevaddr;
usbdwc.c:	hcc |= ep->maxpkt | 1<<OMulticnt | ep->nb<<OEpnum;
usbdwc.c:	switch(ep->ttype){
usbdwc.c:	switch(ep->dev->speed){
usbdwc.c:		if(ep->dev->hub > 1){
usbdwc.c:			hc->hcsplt = Spltena | POS_ALL | ep->dev->hub<<OHubaddr |
usbdwc.c:				ep->dev->port;
usbdwc.c:		hc->hcsplt = 0;
usbdwc.c:	hc->hcchar = hcc;
usbdwc.c:	hc->hcint = ~0;
usbdwc.c:	return (r->gintmsk & Sofintr) == 0;
usbdwc.c:	r = ctlr->regs;
usbdwc.c:		print("sofwait - spin\n");
usbdwc.c:		r->gintsts = Sofintr;
usbdwc.c:		ctlr->sofchan |= 1<<n;
usbdwc.c:		r->gintmsk |= Sofintr;
usbdwc.c:		print("sofwait - spin2\n");
usbdwc.c:		print("sofwait - sleep %d %lux\n", n, &ctlr->chanintr[n]);
usbdwc.c:		sleep(&ctlr->chanintr[n], sofdone, r);
usbdwc.c:	}while((r->hfnum & 7) == 6);
usbdwc.c:	if(hc->hcint == (Chhltd|Ack))
usbdwc.c:	return (hc->hcint & hc->hcintmsk) != 0;
usbdwc.c:	r = ctlr->regs;
usbdwc.c:	n = hc - r->hchan;
usbdwc.c:		r->haintmsk |= 1<<n;
usbdwc.c:		hc->hcintmsk = mask;
usbdwc.c:		tsleep(&ctlr->chanintr[n], chandone, hc, 1000);
usbdwc.c:		if((intr = hc->hcint) == 0)
usbdwc.c:		hc->hcintmsk = 0;
usbdwc.c:			intr = hc->hcint;
usbdwc.c:				   (now - start) > 60)
usbdwc.c:					dprint("await %x after %ldµs %x -> %x\n",
usbdwc.c:						mask, now - start, ointr, intr);
usbdwc.c:					dprint("ep%d.%d await %x after %ldµs intr %x -> %x\n",
usbdwc.c:						ep->dev->nb, ep->nb, mask, now - start, ointr, intr);
usbdwc.c:		}while(now - start < 100);
usbdwc.c:			ep->dev->nb, ep->nb, intr, hc->hcchar, r->grxstsr,
usbdwc.c:			r->gnptxsts, r->hptxsts);
usbdwc.c:		hc->hcchar |= Chdis;
usbdwc.c:		start = m->ticks;
usbdwc.c:		while(hc->hcchar & Chen){
usbdwc.c:			if(m->ticks - start >= 100){
usbdwc.c:					ep->dev->nb, ep->nb, hc->hcchar);
usbdwc.c:	hc = &ctlr->regs->hchan[n];
usbdwc.c:	if((hc->hcint & hc->hcintmsk) == 0)
usbdwc.c:	if(ctlr->debugchan & (1<<n))
usbdwc.c:	if((hc->hcsplt & Spltena) == 0)
usbdwc.c:	i = hc->hcint;
usbdwc.c:		hc->hcsplt |= Compsplt;
usbdwc.c:		ctlr->splitretry = 0;
usbdwc.c:		if(++ctlr->splitretry >= 3)
usbdwc.c:	if(hc->hcchar & Chen){
usbdwc.c:		iprint("hcchar %8.8ux hcint %8.8ux", hc->hcchar, hc->hcint);
usbdwc.c:		hc->hcchar |= Chen | Chdis;
usbdwc.c:		while(hc->hcchar&Chen)
usbdwc.c:		iprint(" %8.8ux\n", hc->hcint);
usbdwc.c:	hc->hcint = i;
usbdwc.c:	if(ctlr->regs->hfnum & 1)
usbdwc.c:		hc->hcchar &= ~Oddfrm;
usbdwc.c:		hc->hcchar |= Oddfrm;
usbdwc.c:	hc->hcchar = (hc->hcchar &~ Chdis) | Chen;
usbdwc.c:	if(ep->debug)
usbdwc.c:	if(ep != nil && !ep->debug)
usbdwc.c:		nchanlog--;
usbdwc.c:	p[0] = dwc.regs->hfnum;
usbdwc.c:	p[1] = hc->hcchar;
usbdwc.c:	p[2] = hc->hcint;
usbdwc.c:	p[3] = hc->hctsiz;
usbdwc.c:	p[4] = hc->hcdma;
usbdwc.c:	if(!ep->debug)
usbdwc.c:	ctlr = ep->hp->aux;
usbdwc.c:	maxpkt = ep->maxpkt;
usbdwc.c:	npkt = HOWMANY(len, ep->maxpkt);
usbdwc.c:	hc->hcchar = (hc->hcchar & ~Epdir) | dir;
usbdwc.c:		n = ROUND(len, ep->maxpkt);
usbdwc.c:	hc->hctsiz = n | npkt<<OPktcnt | pid;
usbdwc.c:	hc->hcdma  = dmaaddr(a);
usbdwc.c:		hcdma = hc->hcdma;
usbdwc.c:		hctsiz = hc->hctsiz;
usbdwc.c:		hc->hctsiz = hctsiz & ~Dopng;
usbdwc.c:		if(hc->hcchar&Chen){
usbdwc.c:				ep->dev->nb, ep->nb, hc->hcchar);
usbdwc.c:			hc->hcchar |= Chen | Chdis;
usbdwc.c:			print("chanio - spin3\n");
usbdwc.c:			while(hc->hcchar&Chen)
usbdwc.c:			hc->hcint = Chhltd;
usbdwc.c:		if((i = hc->hcint) != 0){
usbdwc.c:				ep->dev->nb, ep->nb, i);
usbdwc.c:			hc->hcint = i;
usbdwc.c:		if(hc->hcsplt & Spltena){
usbdwc.c:			qlock(&ctlr->split);
usbdwc.c:			sofwait(ctlr, hc - ctlr->regs->hchan);
usbdwc.c:			if((dwc.regs->hfnum & 1) == 0)
usbdwc.c:				hc->hcchar &= ~Oddfrm;
usbdwc.c:				hc->hcchar |= Oddfrm;
usbdwc.c:		hc->hcchar = (hc->hcchar &~ Chdis) | Chen;
usbdwc.c:		if(ep->ttype == Tbulk && dir == Epin)
usbdwc.c:		else if(ep->ttype == Tintr && (hc->hcsplt & Spltena))
usbdwc.c:		if(hc->hcint != i){
usbdwc.c:			dprint("chanwait intr %ux->%ux\n", i, hc->hcint);
usbdwc.c:			if((i = hc->hcint) == 0)
usbdwc.c:		hc->hcint = i;
usbdwc.c:		if(hc->hcsplt & Spltena){
usbdwc.c:			hc->hcsplt &= ~Compsplt;
usbdwc.c:			qunlock(&ctlr->split);
usbdwc.c:				if(ep->ttype == Tintr)
usbdwc.c:					tsleep(&up->sleep, return0, 0, ep->pollival);
usbdwc.c:					tsleep(&up->sleep, return0, 0, 1);
usbdwc.c:				ep->dev->nb, ep->nb, i);
usbdwc.c:			if(hc->hcdma != hcdma)
usbdwc.c:				print("usbotg: weird hcdma %ux->%ux intr %ux->%ux\n",
usbdwc.c:					hcdma, hc->hcdma, i, hc->hcint);
usbdwc.c:		n = hc->hcdma - hcdma;
usbdwc.c:			if((hc->hctsiz & Pktcnt) != (hctsiz & Pktcnt))
usbdwc.c:		if(dir == Epin && ep->ttype == Tbulk){
usbdwc.c:			nt = (hctsiz & Xfersize) - (hc->hctsiz & Xfersize);
usbdwc.c:						"dma %8.8ux-%8.8ux "
usbdwc.c:						"hctsiz %8.8ux-%8.ux\n",
usbdwc.c:						i, hcdma, hc->hcdma, hctsiz,
usbdwc.c:						hc->hctsiz);
usbdwc.c:					len, len - nleft + n);
usbdwc.c:		nleft -= n;
usbdwc.c:		if((i & Xfercomp) && ep->ttype != Tctl)
usbdwc.c:			dprint("too little: nleft %d hcdma %x->%x hctsiz %x->%x intr %x\n",
usbdwc.c:				nleft, hcdma, hc->hcdma, hctsiz, hc->hctsiz, i);
usbdwc.c:	return len - nleft;
usbdwc.c:		m = n - sofar;
usbdwc.c:		if(m > ep->maxpkt)
usbdwc.c:			m = ep->maxpkt;
usbdwc.c:		m = chanio(ep, hc, rw == Read? Epin : Epout, ep->toggle[rw],
usbdwc.c:		ep->toggle[rw] = hc->hctsiz & Pid;
usbdwc.c:	}while(sofar < n && m == ep->maxpkt);
usbdwc.c:	if(ep->clrhalt){
usbdwc.c:		ep->clrhalt = 0;
usbdwc.c:		if(ep->mode != OREAD)
usbdwc.c:			ep->toggle[Write] = DATA0;
usbdwc.c:		if(ep->mode != OWRITE)
usbdwc.c:			ep->toggle[Read] = DATA0;
usbdwc.c:		ep->toggle[rw] = hc->hctsiz & Pid;
usbdwc.c:		if(strcmp(up->errstr, Estalled) == 0)
usbdwc.c:	if(rw == Read && ep->ttype == Tbulk)
usbdwc.c:		n = chanio(ep, hc, rw == Read? Epin : Epout, ep->toggle[rw],
usbdwc.c:		ep->toggle[rw] = hc->hctsiz & Pid;
usbdwc.c:	epio = ep->aux;
usbdwc.c:	if(epio->cb != nil){
usbdwc.c:		freeb(epio->cb);
usbdwc.c:		epio->cb = nil;
usbdwc.c:		epio->cb = b = allocb(ROUND(datalen, ep->maxpkt));
usbdwc.c:		assert(((uintptr)b->wp & (BLOCKALIGN-1)) == 0);
usbdwc.c:		memset(b->wp, 0x55, b->lim - b->wp);
usbdwc.c:		cachedwbinvse(b->wp, b->lim - b->wp);
usbdwc.c:		data = b->wp;
usbdwc.c:		datalen = n - Rsetuplen;
usbdwc.c:		if(strcmp(up->errstr, Estalled) == 0)
usbdwc.c:		if(ep->dev->hub <= 1){
usbdwc.c:			ep->toggle[Read] = DATA1;
usbdwc.c:			b->wp += multitrans(ep, hc, Read, data, datalen);
usbdwc.c:			b->wp += chanio(ep, hc, Epin, DATA1, data, datalen);
usbdwc.c:		cachedinvse(b->rp, BLEN(b));
usbdwc.c:	epio = ep->aux;
usbdwc.c:	b = epio->cb;
usbdwc.c:	memmove(a, b->rp, n);
usbdwc.c:	b->rp += n;
usbdwc.c:		epio->cb = nil;
usbdwc.c:	r->grstctl |= bits;
usbdwc.c:	while(r->grstctl & bits)
usbdwc.c:	ctlr = hp->aux;
usbdwc.c:	r = ctlr->regs;
usbdwc.c:	ctlr->nchan = 1 + ((r->ghwcfg2 & Num_host_chan) >> ONum_host_chan);
usbdwc.c:	ctlr->chanintr = malloc(ctlr->nchan * sizeof(Rendez));
usbdwc.c:	r->gahbcfg = 0;
usbdwc.c:	while((r->grstctl&Ahbidle) == 0)
usbdwc.c:	r->gusbcfg |= Force_host_mode;
usbdwc.c:	tsleep(&up->sleep, return0, 0, 25);
usbdwc.c:	r->gahbcfg |= Dmaenable;
usbdwc.c:	n = (r->ghwcfg3 & Dfifo_depth) >> ODfifo_depth;
usbdwc.c:	r->grxfsiz = rx;
usbdwc.c:	r->gnptxfsiz = rx | tx<<ODepth;
usbdwc.c:	tsleep(&up->sleep, return0, 0, 1);
usbdwc.c:	r->hptxfsiz = (rx + tx) | ptx << ODepth;
usbdwc.c:	r->grstctl = TXF_ALL;
usbdwc.c:		n, r->grxfsiz, r->gnptxfsiz, r->hptxfsiz);
usbdwc.c:	r->hport0 = Prtpwr|Prtconndet|Prtenchng|Prtovrcurrchng;
usbdwc.c:	r->gintsts = ~0;
usbdwc.c:	r->gintmsk = Hcintr;
usbdwc.c:	r->gahbcfg |= Glblintrmsk;
usbdwc.c:	ctlr = hp->aux;
usbdwc.c:	r = ctlr->regs;
usbdwc.c:	intr = r->gintsts;
usbdwc.c:		haint = r->haint & r->haintmsk;
usbdwc.c:					r->haintmsk &= ~(1<<i);
usbdwc.c:		r->gintsts = Sofintr;
usbdwc.c:		if((r->hfnum&7) != 6){
usbdwc.c:			r->gintmsk &= ~Sofintr;
usbdwc.c:			wakechan |= ctlr->sofchan;
usbdwc.c:			ctlr->sofchan = 0;
usbdwc.c:		ctlr->wakechan |= wakechan;
usbdwc.c:	wakechan = ctlr->wakechan;
usbdwc.c:	print("irqintr - wakechan %d\n", wakechan);
usbdwc.c:	ctlr->wakechan = 0;
usbdwc.c:			wakeup(&ctlr->chanintr[i]);
usbdwc.c:		ep->dev->nb, ep->nb, ep->ttype);
usbdwc.c:	switch(ep->ttype){
usbdwc.c:		assert(ep->pollival > 0);
usbdwc.c:		if(ep->toggle[Read] == 0)
usbdwc.c:			ep->toggle[Read] = DATA0;
usbdwc.c:		if(ep->toggle[Write] == 0)
usbdwc.c:			ep->toggle[Write] = DATA0;
usbdwc.c:	ep->aux = malloc(sizeof(Epio));
usbdwc.c:	if(ep->aux == nil)
usbdwc.c:		ep->dev->nb, ep->nb, ep->ttype);
usbdwc.c:	switch(ep->ttype){
usbdwc.c:		freeb(((Epio*)ep->aux)->cb);
usbdwc.c:		free(ep->aux);
usbdwc.c:	ddprint("epread ep%d.%d %ld\n", ep->dev->nb, ep->nb, n);
usbdwc.c:	epio = ep->aux;
usbdwc.c:	switch(ep->ttype){
usbdwc.c:		elapsed = TK2MS(m->ticks) - epio->lastpoll;
usbdwc.c:		if(elapsed < ep->pollival)
usbdwc.c:			tsleep(&up->sleep, return0, 0, ep->pollival - elapsed);
usbdwc.c:		b = allocb(ROUND(n, ep->maxpkt));
usbdwc.c:		p = b->rp;
usbdwc.c:		assert(((uintptr)p & (BLOCKALIGN-1)) == 0);
usbdwc.c:		epio->lastpoll = TK2MS(m->ticks);
usbdwc.c:	ddprint("epwrite ep%d.%d %ld\n", ep->dev->nb, ep->nb, n);
usbdwc.c:	epio = ep->aux;
usbdwc.c:	switch(ep->ttype){
usbdwc.c:		elapsed = TK2MS(m->ticks) - epio->lastpoll;
usbdwc.c:		if(elapsed < ep->pollival)
usbdwc.c:			tsleep(&up->sleep, return0, 0, ep->pollival - elapsed);
usbdwc.c:		p = b->wp;
usbdwc.c:		assert(((uintptr)p & (BLOCKALIGN-1)) == 0);
usbdwc.c:		if(ep->ttype == Tctl) {
usbdwc.c:			epio->lastpoll = TK2MS(m->ticks);
usbdwc.c:	ctlr = hp->aux;
usbdwc.c:	r = ctlr->regs;
usbdwc.c:	dprint("usbotg enable=%d; sts %#x\n", on, r->hport0);
usbdwc.c:		r->hport0 = Prtpwr | Prtena;
usbdwc.c:	tsleep(&up->sleep, return0, 0, Enabledelay);
usbdwc.c:	dprint("usbotg enable=%d; sts %#x\n", on, r->hport0);
usbdwc.c:	ctlr = hp->aux;
usbdwc.c:	r = ctlr->regs;
usbdwc.c:	dprint("usbotg reset=%d; sts %#x\n", on, r->hport0);
usbdwc.c:	r->hport0 = Prtpwr | Prtrst;
usbdwc.c:	tsleep(&up->sleep, return0, 0, ResetdelayHS);
usbdwc.c:	r->hport0 = Prtpwr;
usbdwc.c:	tsleep(&up->sleep, return0, 0, Enabledelay);
usbdwc.c:	s = r->hport0;
usbdwc.c:		r->hport0 = Prtpwr | b;
usbdwc.c:	ctlr = hp->aux;
usbdwc.c:	r = ctlr->regs;
usbdwc.c:	s = r->hport0;
usbdwc.c:		r->hport0 = Prtpwr | b;
usbdwc.c:	if(ctlr->regs != nil)
usbdwc.c:		return -1;
usbdwc.c:	ctlr->regs = (Dwcregs*)USBREGS;
usbdwc.c:	id = ctlr->regs->gsnpsid;
usbdwc.c:		return -1;
usbdwc.c:	hp->aux = ctlr;
usbdwc.c:	hp->port = 0;
usbdwc.c:	hp->irq = IRQusb;
usbdwc.c:	hp->tbdf = 0;
usbdwc.c:	hp->nports = 1;
usbdwc.c:	hp->highspeed = 1;
usbdwc.c:	hp->init = init;
usbdwc.c:	hp->dump = dump;
usbdwc.c:	hp->interrupt = fiqintr;
usbdwc.c:	hp->epopen = epopen;
usbdwc.c:	hp->epclose = epclose;
usbdwc.c:	hp->epread = epread;
usbdwc.c:	hp->epwrite = epwrite;
usbdwc.c:	hp->seprintep = seprintep;
usbdwc.c:	hp->portenable = portenable;
usbdwc.c:	hp->portreset = portreset;
usbdwc.c:	hp->portstatus = portstatus;
usbdwc.c:	hp->shutdown = shutdown;
usbdwc.c:	hp->debug = setdebug;
usbdwc.c:	hp->type = "dwcotg";
vcore.c:	prop->len = n;
vcore.c:	prop->req = Req;
vcore.c:	prop->tag = tag;
vcore.c:	prop->tagbuflen = rsplen;
vcore.c:	prop->taglen = vallen;
vcore.c:		memmove(prop->data, buf, vallen);
vcore.c:	cachedwbinvse(prop, prop->len);
vcore.c:			return -1;
vcore.c:	if(prop->req == RspOk &&
vcore.c:	   prop->tag == tag &&
vcore.c:	   (prop->taglen&TagResp)) {
vcore.c:		if((n = prop->taglen & ~TagResp) < rsplen)
vcore.c:		memmove(buf, prop->data, rsplen);
vcore.c:		rsplen = -1;
vcore.c:		return -1;
vcore.c:	fi->xres = fi->xresvirtual = *width;
vcore.c:	fi->yres = fi->yresvirtual = *height;
vcore.c:	fi->bpp = *depth;
vcore.c:	va = mmukmap(FRAMEBUFFER, PADDR(fi->base), fi->screensize);
vcore.c:		memset((char*)va, 0x7F, fi->screensize);
vcore.c:		return -1;
vcore.c:		return -1;
vcore.c:	mem->base = buf[0];
vcore.c:	mem->limit = buf[1];
vcore.c: * Virtual GPIO - used for ACT LED on pi3
vfp3.c:/* subarchitecture code in m->havefp */
vfp3.c:/* fp control regs.  most are read-only */
vfp3.c:	if (m->havefpvalid)
vfp3.c:		return m->havefp;
vfp3.c:	m->havefp = 0;
vfp3.c:		m->havefpvalid = 1;
vfp3.c:	m->fpon = 1;			/* don't panic */
vfp3.c:	m->fpon = 0;
vfp3.c:		m->havefp = VFPv2;
vfp3.c:		m->fpnregs = 16;
vfp3.c:		m->havefp = VFPv3;
vfp3.c:		m->fpnregs = (acc & Cpaccd16) ? 16 : 32;
vfp3.c:	if (m->machno == 0)
vfp3.c:		print("fp: %d registers, %s simd\n", m->fpnregs,
vfp3.c:	m->havefpvalid = 1;
vfp3.c:	if (m->fpon) {
vfp3.c:		m->fpon = 0;
vfp3.c:	if (!m->fpon && havefp()) {
vfp3.c:		m->fpon = 1;
vfp3.c:	m->fpscr = Dn | FPRNR | (FPINVAL | FPZDIV | FPOVFL) & ~Alltraps;
vfp3.c:	if(m->havefp == VFPv2)
vfp3.c:		m->fpscr |= Fz;
vfp3.c:	fpwr(Fpscr, m->fpscr);
vfp3.c:	m->fpconfiged = 1;
vfp3.c:		if (m->fpconfiged)
vfp3.c:			fpwr(Fpscr, (fprd(Fpscr) & Allcc) | m->fpscr);
vfp3.c://	m->fpscr = scr & ~Allexc;
vfp3.c://	fpwr(Fpscr, m->fpscr);
vfp3.c:	if(up->fpstate == FPactive){
vfp3.c:		fpsave(&up->fpsave);
vfp3.c:		up->fpstate = FPinactive;
vfp3.c:	up->fpstate |= FPillegal;
vfp3.c: * Called from sysnoted() via the machine-dependent
vfp3.c:	up->fpstate &= ~FPillegal;
vfp3.c: * Called early in the non-interruptible path of
vfp3.c: * sysrfork() via the machine-dependent syscall() routine.
vfp3.c:	if(up->fpstate == FPactive){
vfp3.c:		fpsave(&up->fpsave);
vfp3.c:		up->fpstate = FPinactive;
vfp3.c: * Called later in sysrfork() via the machine-dependent
vfp3.c:	p->fpstate = up->fpstate & ~FPillegal;
vfp3.c:/* should only be called if p->fpstate == FPactive */
vfp3.c:	fps->control = fps->status = fprd(Fpscr);
vfp3.c:	assert(m->fpnregs);
vfp3.c:	for (n = 0; n < m->fpnregs; n++)
vfp3.c:		fpsavereg(n, (uvlong *)fps->regs[n]);
vfp3.c:	fpwr(Fpscr, p->fpsave.control);
vfp3.c:	m->fpscr = fprd(Fpscr) & ~Allcc;
vfp3.c:	assert(m->fpnregs);
vfp3.c:	for (n = 0; n < m->fpnregs; n++)
vfp3.c:		fprestreg(n, *(uvlong *)p->fpsave.regs[n]);
vfp3.c: * Called from sched() and sleep() via the machine-dependent
vfp3.c:	if(p->fpstate == FPactive){
vfp3.c:		if(p->state == Moribund)
vfp3.c:			 * here as sleep() already has up->rlock, so
vfp3.c:			fpsave(&p->fpsave);
vfp3.c:		p->fpstate = FPinactive;
vfp3.c:	switch(up->fpstate & ~FPillegal){
vfp3.c:		fpsave(&up->fpsave);
vfp3.c:		up->fpstate = FPinactive;
vfp3.c:		p->fpsave = up->fpsave;
vfp3.c:		p->fpstate = FPinactive;
vfp3.c:	p->fpstate = FPinit;
vfp3.c:	status = up->fpsave.status;
vfp3.c:		msg, up->fpsave.pc, status);
vfp3.c:	switch(up->fpstate){
vfp3.c:		up->fpstate = FPactive;
vfp3.c:		if(up->fpsave.status & (FPAINEX|FPAUNFL|FPAOVFL|FPAZDIV|FPAINVAL)){
vfp3.c:		up->fpstate = FPactive;
vfp3.c:	if (m->fppc == pc && m->fppid == up->pid) {
vfp3.c:		m->fpcnt++;
vfp3.c:		if (m->fpcnt > 4)
vfp3.c:				"instr %#8.8lux", m->machno, up->pid, up->text,
vfp3.c:		m->fppid = up->pid;
vfp3.c:		m->fppc = pc;
vfp3.c:		m->fpcnt = 0;
vfp3.c:/* only called to deal with user-mode instruction faults */
vfp3.c:		postnote(up, 1, up->errstr, NDebug);
vfp3.c:	if(up->fpstate & FPillegal)
vfp3.c:	pc = ureg->pc;
vfp3.c:	if(m->fpon)
vfp3.c:			m->fppc = m->fpcnt = 0;
